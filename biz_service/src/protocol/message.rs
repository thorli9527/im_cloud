// This file is @generated by prost-build.
/// ======================================
/// ğŸ’  æ¶ˆæ¯å†…å®¹ç»“æ„ï¼ˆoneof ç±»å‹ï¼‰
/// ======================================
/// ä½¿ç”¨ oneof å®šä¹‰ä¸åŒç±»å‹çš„æ¶ˆæ¯å†…å®¹ï¼Œç¡®ä¿æ¶ˆæ¯ç±»å‹çš„äº’æ–¥æ€§
#[derive(serde::Serialize, serde::Deserialize, utoipa::ToSchema)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MessageContent {
    #[prost(
        oneof = "message_content::Content",
        tags = "1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21"
    )]
    pub content: ::core::option::Option<message_content::Content>,
}
/// Nested message and enum types in `MessageContent`.
pub mod message_content {
    #[derive(serde::Serialize, serde::Deserialize, utoipa::ToSchema)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Content {
        /// æ–‡æœ¬æ¶ˆæ¯ï¼šçº¯æ–‡æœ¬å†…å®¹
        #[prost(message, tag = "1")]
        Text(super::TextContent),
        /// å›¾ç‰‡æ¶ˆæ¯ï¼šå›¾ç‰‡æ–‡ä»¶
        #[prost(message, tag = "2")]
        Image(super::ImageContent),
        /// éŸ³é¢‘æ¶ˆæ¯ï¼šè¯­éŸ³æˆ–éŸ³ä¹
        #[prost(message, tag = "3")]
        Audio(super::AudioContent),
        /// è§†é¢‘æ¶ˆæ¯ï¼šè§†é¢‘æ–‡ä»¶
        #[prost(message, tag = "4")]
        Video(super::VideoContent),
        /// ä½ç½®æ¶ˆæ¯ï¼šåœ°ç†ä½ç½®ä¿¡æ¯
        #[prost(message, tag = "5")]
        Location(super::LocationContent),
        /// æ–‡ä»¶æ¶ˆæ¯ï¼šä»»æ„æ–‡ä»¶ç±»å‹
        #[prost(message, tag = "6")]
        File(super::FileContent),
        /// éŸ³è§†é¢‘é€šè¯ä¿¡ä»¤ï¼šé€šè¯æ§åˆ¶æ¶ˆæ¯
        #[prost(message, tag = "7")]
        AvCall(super::AvCallContent),
        /// è‡ªå®šä¹‰æ¶ˆæ¯ï¼šå¼€å‘è€…è‡ªå®šä¹‰ç»“æ„
        #[prost(message, tag = "8")]
        Custom(super::CustomContent),
        /// è¡¨æƒ…æ¶ˆæ¯ï¼šemoji è¡¨æƒ…
        #[prost(message, tag = "9")]
        Emoji(super::EmojiContent),
        /// æ’¤å›æ¶ˆæ¯ï¼šæ¶ˆæ¯æ’¤å›é€šçŸ¥
        #[prost(message, tag = "10")]
        Revoke(super::RevokeContent),
        /// è½¬å‘æ¶ˆæ¯ï¼šæ¶ˆæ¯è½¬å‘
        #[prost(message, tag = "11")]
        Forward(super::ForwardContent),
        /// å¼•ç”¨å›å¤æ¶ˆæ¯ï¼šå›å¤ç‰¹å®šæ¶ˆæ¯
        #[prost(message, tag = "12")]
        Quote(super::QuoteContent),
        /// HTML å¡ç‰‡ï¼šå¯Œæ–‡æœ¬å†…å®¹
        #[prost(message, tag = "13")]
        Html(super::HtmlContent),
        /// VOIP é€šè¯è®°å½•ï¼šé€šè¯æ—¥å¿—
        #[prost(message, tag = "14")]
        Voip(super::VoipContent),
        /// é€šçŸ¥æ¶ˆæ¯ï¼šç³»ç»Ÿé€šçŸ¥
        #[prost(message, tag = "15")]
        Notification(super::NotificationContent),
        /// ç³»ç»Ÿæ¶ˆæ¯ï¼šç³»ç»Ÿçº§æ¶ˆæ¯
        #[prost(message, tag = "16")]
        System(super::SystemContent),
        /// æé†’æ¶ˆæ¯ï¼šæé†’äº‹é¡¹
        #[prost(message, tag = "17")]
        Reminder(super::ReminderContent),
        /// ç¾¤ç»„äº‹ä»¶ï¼šç¾¤ç»„ç›¸å…³äº‹ä»¶
        #[prost(message, tag = "18")]
        GroupEvent(super::GroupEventContent),
        /// åç‰‡æ¶ˆæ¯ï¼šè”ç³»äººåˆ†äº«
        #[prost(message, tag = "19")]
        ContactCard(super::ContactCardContent),
        /// æŠ•ç¥¨æ¶ˆæ¯ï¼šæŠ•ç¥¨å†…å®¹
        #[prost(message, tag = "20")]
        Vote(super::VoteContent),
        /// çº¢åŒ…æ¶ˆæ¯ï¼šçº¢åŒ…å†…å®¹
        #[prost(message, tag = "21")]
        RedEnvelope(super::RedEnvelopeContent),
    }
}
/// ===============================
/// ğŸ“„ æ–‡æœ¬æ¶ˆæ¯
/// ===============================
/// æ”¯æŒçº¯æ–‡æœ¬å’Œå¯Œæ–‡æœ¬æ ¼å¼ï¼ŒåŒ…å«å†…è”å®ä½“ï¼ˆé“¾æ¥ã€@ç”¨æˆ·ã€è¯é¢˜ç­‰ï¼‰
#[derive(serde::Serialize, serde::Deserialize, utoipa::ToSchema)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TextContent {
    /// æ–‡æœ¬ä¸»ä½“å†…å®¹ï¼šæ¶ˆæ¯çš„æ–‡æœ¬å†…å®¹
    #[prost(string, tag = "1")]
    pub text: ::prost::alloc::string::String,
    /// å¯Œæ–‡æœ¬å®ä½“ï¼Œå¦‚é“¾æ¥/@ç”¨æˆ·/è¯é¢˜ï¼šæ–‡æœ¬ä¸­çš„ç‰¹æ®Šå…ƒç´ 
    #[prost(message, repeated, tag = "2")]
    pub entities: ::prost::alloc::vec::Vec<InlineEntity>,
}
/// å†…è”å®ä½“ï¼šç”¨äºåœ¨æ–‡æœ¬ä¸­æ ‡è®°ç‰¹æ®Šå…ƒç´ 
#[derive(serde::Serialize, serde::Deserialize, utoipa::ToSchema)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InlineEntity {
    /// èµ·å§‹ä½ç½®ï¼ˆUTF-8 å­—ç¬¦ç´¢å¼•ï¼‰ï¼šå®ä½“åœ¨æ–‡æœ¬ä¸­çš„å¼€å§‹ä½ç½®
    #[prost(int32, tag = "1")]
    pub start: i32,
    /// ç»“æŸä½ç½®ï¼ˆä¸å«ï¼‰ï¼šå®ä½“åœ¨æ–‡æœ¬ä¸­çš„ç»“æŸä½ç½®
    #[prost(int32, tag = "2")]
    pub end: i32,
    /// ç±»å‹ï¼šlink / mention / hashtagï¼šå®ä½“çš„ç±»å‹
    #[prost(string, tag = "3")]
    pub r#type: ::prost::alloc::string::String,
    /// é™„åŠ å€¼ï¼šURLã€ç”¨æˆ·IDç­‰ï¼šå®ä½“çš„å…·ä½“å€¼
    #[prost(string, tag = "4")]
    pub value: ::prost::alloc::string::String,
}
/// ===============================
/// ğŸ–¼ï¸ å›¾ç‰‡æ¶ˆæ¯
/// ===============================
/// åŒ…å«å›¾ç‰‡çš„å®Œæ•´ä¿¡æ¯ï¼Œæ”¯æŒåŸå›¾å’Œç¼©ç•¥å›¾
#[derive(serde::Serialize, serde::Deserialize, utoipa::ToSchema)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImageContent {
    /// åŸå›¾ URLï¼šå›¾ç‰‡çš„å®Œæ•´åœ°å€
    #[prost(string, tag = "1")]
    pub url: ::prost::alloc::string::String,
    /// ç¼©ç•¥å›¾ URLï¼šå›¾ç‰‡çš„ç¼©ç•¥å›¾åœ°å€
    #[prost(string, tag = "2")]
    pub thumbnail_url: ::prost::alloc::string::String,
    /// å®½åº¦ï¼ˆåƒç´ ï¼‰ï¼šå›¾ç‰‡çš„å®½åº¦
    #[prost(int32, tag = "3")]
    pub width: i32,
    /// é«˜åº¦ï¼ˆåƒç´ ï¼‰ï¼šå›¾ç‰‡çš„é«˜åº¦
    #[prost(int32, tag = "4")]
    pub height: i32,
    /// æ ¼å¼ï¼ˆå¦‚ jpg/pngï¼‰ï¼šå›¾ç‰‡çš„æ–‡ä»¶æ ¼å¼
    #[prost(string, tag = "5")]
    pub format: ::prost::alloc::string::String,
    /// æ–‡ä»¶å¤§å°ï¼ˆå­—èŠ‚ï¼‰ï¼šå›¾ç‰‡æ–‡ä»¶çš„å¤§å°
    #[prost(int64, tag = "6")]
    pub size: i64,
}
/// ===============================
/// ğŸ”Š éŸ³é¢‘æ¶ˆæ¯
/// ===============================
/// æ”¯æŒè¯­éŸ³èŠå¤©å’ŒéŸ³ä¹æ’­æ”¾ï¼ŒåŒ…å«æ—¶é•¿å’Œæ ¼å¼ä¿¡æ¯
#[derive(serde::Serialize, serde::Deserialize, utoipa::ToSchema)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AudioContent {
    /// éŸ³é¢‘æ–‡ä»¶ URLï¼šéŸ³é¢‘æ–‡ä»¶çš„åœ°å€
    #[prost(string, tag = "1")]
    pub url: ::prost::alloc::string::String,
    /// æ—¶é•¿ï¼ˆç§’ï¼‰ï¼šéŸ³é¢‘çš„æ’­æ”¾æ—¶é•¿
    #[prost(int32, tag = "2")]
    pub duration: i32,
    /// æ ¼å¼ï¼šéŸ³é¢‘æ–‡ä»¶æ ¼å¼ï¼ˆå¦‚ mp3/wavï¼‰
    #[prost(string, tag = "3")]
    pub format: ::prost::alloc::string::String,
    /// æ–‡ä»¶å¤§å°ï¼ˆå­—èŠ‚ï¼‰ï¼šéŸ³é¢‘æ–‡ä»¶çš„å¤§å°
    #[prost(int64, tag = "4")]
    pub size: i64,
    /// æ˜¯å¦è¯­éŸ³ï¼ˆvs éŸ³ä¹ç±»éŸ³é¢‘ï¼‰ï¼štrueè¡¨ç¤ºè¯­éŸ³ï¼Œfalseè¡¨ç¤ºéŸ³ä¹
    #[prost(bool, tag = "5")]
    pub is_voice: bool,
}
/// ===============================
/// ğŸï¸ è§†é¢‘æ¶ˆæ¯
/// ===============================
/// åŒ…å«è§†é¢‘æ–‡ä»¶å’Œå°é¢å›¾ï¼Œæ”¯æŒæ’­æ”¾æ§åˆ¶
#[derive(serde::Serialize, serde::Deserialize, utoipa::ToSchema)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VideoContent {
    /// è§†é¢‘æ–‡ä»¶ URLï¼šè§†é¢‘æ–‡ä»¶çš„åœ°å€
    #[prost(string, tag = "1")]
    pub url: ::prost::alloc::string::String,
    /// æ—¶é•¿ï¼ˆç§’ï¼‰ï¼šè§†é¢‘çš„æ’­æ”¾æ—¶é•¿
    #[prost(int32, tag = "2")]
    pub duration: i32,
    /// å°é¢å›¾ URLï¼šè§†é¢‘çš„å°é¢å›¾ç‰‡
    #[prost(string, tag = "3")]
    pub cover_url: ::prost::alloc::string::String,
    /// å®½åº¦ï¼ˆåƒç´ ï¼‰ï¼šè§†é¢‘çš„å®½åº¦
    #[prost(int32, tag = "4")]
    pub width: i32,
    /// é«˜åº¦ï¼ˆåƒç´ ï¼‰ï¼šè§†é¢‘çš„é«˜åº¦
    #[prost(int32, tag = "5")]
    pub height: i32,
    /// æ ¼å¼ï¼šè§†é¢‘æ–‡ä»¶æ ¼å¼ï¼ˆå¦‚ mp4/aviï¼‰
    #[prost(string, tag = "6")]
    pub format: ::prost::alloc::string::String,
    /// æ–‡ä»¶å¤§å°ï¼ˆå­—èŠ‚ï¼‰ï¼šè§†é¢‘æ–‡ä»¶çš„å¤§å°
    #[prost(int64, tag = "7")]
    pub size: i64,
}
/// ===============================
/// ğŸ“ ä½ç½®æ¶ˆæ¯
/// ===============================
/// åŒ…å«åœ°ç†ä½ç½®ä¿¡æ¯ï¼Œæ”¯æŒåœ°å€æè¿°å’Œåœ°å›¾æ˜¾ç¤º
#[derive(serde::Serialize, serde::Deserialize, utoipa::ToSchema)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LocationContent {
    /// çº¬åº¦ï¼šåœ°ç†ä½ç½®çš„çº¬åº¦åæ ‡
    #[prost(double, tag = "1")]
    pub latitude: f64,
    /// ç»åº¦ï¼šåœ°ç†ä½ç½®çš„ç»åº¦åæ ‡
    #[prost(double, tag = "2")]
    pub longitude: f64,
    /// åœ°å€æè¿°ï¼šä½ç½®çš„æ–‡å­—æè¿°
    #[prost(string, tag = "3")]
    pub address: ::prost::alloc::string::String,
    /// åœ°ç‚¹åç§°ï¼šå…·ä½“çš„åœ°ç‚¹åç§°
    #[prost(string, tag = "4")]
    pub poi_name: ::prost::alloc::string::String,
    /// ç¼©ç•¥å›¾ URLï¼šä½ç½®çš„åœ°å›¾ç¼©ç•¥å›¾
    #[prost(string, tag = "5")]
    pub thumbnail_url: ::prost::alloc::string::String,
}
/// ===============================
/// ğŸ“ æ–‡ä»¶æ¶ˆæ¯
/// ===============================
/// æ”¯æŒä»»æ„æ–‡ä»¶ç±»å‹ï¼ŒåŒ…å«æ–‡ä»¶ä¿¡æ¯å’Œå›¾æ ‡
#[derive(serde::Serialize, serde::Deserialize, utoipa::ToSchema)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FileContent {
    /// æ–‡ä»¶ URLï¼šæ–‡ä»¶çš„ä¸‹è½½åœ°å€
    #[prost(string, tag = "1")]
    pub url: ::prost::alloc::string::String,
    /// æ–‡ä»¶åï¼šæ–‡ä»¶çš„æ˜¾ç¤ºåç§°
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// æ–‡ä»¶å¤§å°ï¼ˆå­—èŠ‚ï¼‰ï¼šæ–‡ä»¶çš„å¤§å°
    #[prost(int64, tag = "3")]
    pub size: i64,
    /// æ–‡ä»¶ç±»å‹ï¼šæ–‡ä»¶çš„ MIME ç±»å‹
    #[prost(string, tag = "4")]
    pub file_type: ::prost::alloc::string::String,
    /// å›¾æ ‡ URLï¼šæ–‡ä»¶ç±»å‹çš„å›¾æ ‡
    #[prost(string, tag = "5")]
    pub icon_url: ::prost::alloc::string::String,
}
/// ===============================
/// ğŸ“ éŸ³è§†é¢‘é€šè¯ä¿¡ä»¤
/// ===============================
/// ç”¨äºéŸ³è§†é¢‘é€šè¯çš„æ§åˆ¶ä¿¡ä»¤ï¼ŒåŒ…å«é€šè¯çŠ¶æ€å’Œå‚ä¸è€…ä¿¡æ¯
#[derive(serde::Serialize, serde::Deserialize, utoipa::ToSchema)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AvCallContent {
    /// é€šè¯ IDï¼šé€šè¯çš„å”¯ä¸€æ ‡è¯†
    #[prost(string, tag = "1")]
    pub call_id: ::prost::alloc::string::String,
    /// å‘èµ·è€… IDï¼šé€šè¯çš„å‘èµ·ç”¨æˆ·
    #[prost(string, tag = "2")]
    pub initiator_id: ::prost::alloc::string::String,
    /// å‚ä¸è€… ID åˆ—è¡¨ï¼šé€šè¯çš„æ‰€æœ‰å‚ä¸è€…
    #[prost(string, repeated, tag = "3")]
    pub participant_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// é€šè¯æ“ä½œï¼šå…·ä½“çš„é€šè¯åŠ¨ä½œ
    #[prost(enumeration = "av_call_content::CallAction", tag = "4")]
    pub action: i32,
    /// é€šè¯ç±»å‹ï¼šé€šè¯çš„ç±»å‹
    #[prost(enumeration = "av_call_content::CallType", tag = "5")]
    pub r#type: i32,
    /// æ—¶é—´æˆ³ï¼šæ“ä½œçš„æ—¶é—´
    #[prost(int64, tag = "6")]
    pub timestamp: i64,
    /// æ—¶é•¿ï¼ˆç§’ï¼‰ï¼šé€šè¯çš„æŒç»­æ—¶é—´
    #[prost(int32, tag = "7")]
    pub duration: i32,
}
/// Nested message and enum types in `AVCallContent`.
pub mod av_call_content {
    #[derive(serde::Serialize, serde::Deserialize, utoipa::ToSchema)]
    #[serde(rename_all = "camelCase")]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CallAction {
        /// æœªçŸ¥æ“ä½œ
        Unknown = 0,
        /// é‚€è¯·ï¼šå‘èµ·é€šè¯é‚€è¯·
        Invite = 1,
        /// æ¥å—ï¼šæ¥å—é€šè¯é‚€è¯·
        Accept = 2,
        /// æ‹’ç»ï¼šæ‹’ç»é€šè¯é‚€è¯·
        Reject = 3,
        /// å–æ¶ˆï¼šå–æ¶ˆé€šè¯
        Cancel = 4,
        /// ç»“æŸï¼šç»“æŸé€šè¯
        End = 5,
        /// è¶…æ—¶ï¼šé€šè¯è¶…æ—¶
        Timeout = 6,
    }
    impl CallAction {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "UNKNOWN",
                Self::Invite => "INVITE",
                Self::Accept => "ACCEPT",
                Self::Reject => "REJECT",
                Self::Cancel => "CANCEL",
                Self::End => "END",
                Self::Timeout => "TIMEOUT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNKNOWN" => Some(Self::Unknown),
                "INVITE" => Some(Self::Invite),
                "ACCEPT" => Some(Self::Accept),
                "REJECT" => Some(Self::Reject),
                "CANCEL" => Some(Self::Cancel),
                "END" => Some(Self::End),
                "TIMEOUT" => Some(Self::Timeout),
                _ => None,
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize, utoipa::ToSchema)]
    #[serde(rename_all = "camelCase")]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CallType {
        /// éŸ³é¢‘é€šè¯ï¼šä»…è¯­éŸ³é€šè¯
        Audio = 0,
        /// è§†é¢‘é€šè¯ï¼šéŸ³è§†é¢‘é€šè¯
        Video = 1,
    }
    impl CallType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Audio => "AUDIO",
                Self::Video => "VIDEO",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "AUDIO" => Some(Self::Audio),
                "VIDEO" => Some(Self::Video),
                _ => None,
            }
        }
    }
}
/// ===============================
/// ğŸ’  è‡ªå®šä¹‰ç»“æ„åŒ–æ¶ˆæ¯
/// ===============================
/// æ”¯æŒå¼€å‘è€…è‡ªå®šä¹‰çš„æ¶ˆæ¯ç»“æ„ï¼Œé€šå¸¸ä»¥ JSON æ ¼å¼æ‰¿è½½
#[derive(serde::Serialize, serde::Deserialize, utoipa::ToSchema)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomContent {
    /// è‡ªå®šä¹‰ç±»å‹ï¼šæ¶ˆæ¯çš„è‡ªå®šä¹‰ç±»å‹æ ‡è¯†
    #[prost(string, tag = "1")]
    pub custom_type: ::prost::alloc::string::String,
    /// JSON è½½è·ï¼šè‡ªå®šä¹‰æ¶ˆæ¯çš„ JSON æ•°æ®
    #[prost(string, tag = "2")]
    pub json_payload: ::prost::alloc::string::String,
}
/// ===============================
/// ğŸ˜„ è¡¨æƒ…æ¶ˆæ¯
/// ===============================
/// æ”¯æŒæ ‡å‡† emoji å’Œè‡ªå®šä¹‰è¡¨æƒ…
#[derive(serde::Serialize, serde::Deserialize, utoipa::ToSchema)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EmojiContent {
    /// è¡¨æƒ…ç±»å‹ï¼šæ ‡å‡† emoji ç±»å‹
    #[prost(enumeration = "EmojiType", tag = "1")]
    pub emoji: i32,
    /// è‡ªå®šä¹‰è¡¨æƒ… URLï¼šè‡ªå®šä¹‰è¡¨æƒ…çš„å›¾ç‰‡åœ°å€
    #[prost(string, tag = "2")]
    pub custom_emoji_url: ::prost::alloc::string::String,
}
/// ===============================
/// â›” æ’¤å›æ¶ˆæ¯
/// ===============================
/// ç”¨äºé€šçŸ¥æ¶ˆæ¯æ’¤å›ï¼ŒåŒ…å«æ’¤å›çš„ç›®æ ‡æ¶ˆæ¯ä¿¡æ¯
#[derive(serde::Serialize, serde::Deserialize, utoipa::ToSchema)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RevokeContent {
    /// ç›®æ ‡æ¶ˆæ¯ IDï¼šè¢«æ’¤å›çš„æ¶ˆæ¯ID
    #[prost(uint64, tag = "1")]
    pub target_message_id: u64,
    /// æ“ä½œè€… IDï¼šæ‰§è¡Œæ’¤å›æ“ä½œçš„ç”¨æˆ·
    #[prost(string, tag = "2")]
    pub operator_id: ::prost::alloc::string::String,
    /// æ’¤å›æ—¶é—´ï¼šæ’¤å›æ“ä½œçš„æ—¶é—´æˆ³
    #[prost(int64, tag = "3")]
    pub revoke_time: i64,
}
/// ===============================
/// ğŸ“¤ è½¬å‘æ¶ˆæ¯
/// ===============================
/// ç”¨äºæ¶ˆæ¯è½¬å‘ï¼ŒåŒ…å«åŸæ¶ˆæ¯çš„åŸºæœ¬ä¿¡æ¯
#[derive(serde::Serialize, serde::Deserialize, utoipa::ToSchema)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ForwardContent {
    /// åŸæ¶ˆæ¯ IDï¼šè¢«è½¬å‘æ¶ˆæ¯çš„ID
    #[prost(uint64, tag = "1")]
    pub original_message_id: u64,
    /// åŸå‘é€è€… IDï¼šåŸæ¶ˆæ¯çš„å‘é€è€…
    #[prost(string, tag = "2")]
    pub original_sender_id: ::prost::alloc::string::String,
    /// åŸæ¶ˆæ¯ç±»å‹ï¼šåŸæ¶ˆæ¯çš„ç±»å‹
    #[prost(enumeration = "super::super::common::ContentType", tag = "3")]
    pub original_type: i32,
    /// æ‘˜è¦ï¼šè½¬å‘çš„æ‘˜è¦ä¿¡æ¯
    #[prost(string, tag = "4")]
    pub summary: ::prost::alloc::string::String,
}
/// ===============================
/// ğŸ“Œ å¼•ç”¨å›å¤æ¶ˆæ¯
/// ===============================
/// ç”¨äºå›å¤ç‰¹å®šæ¶ˆæ¯ï¼ŒåŒ…å«è¢«å¼•ç”¨æ¶ˆæ¯çš„ä¿¡æ¯
#[derive(serde::Serialize, serde::Deserialize, utoipa::ToSchema)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QuoteContent {
    /// è¢«å¼•ç”¨æ¶ˆæ¯ IDï¼šè¢«å›å¤æ¶ˆæ¯çš„ID
    #[prost(uint64, tag = "1")]
    pub quoted_message_id: u64,
    /// è¢«å¼•ç”¨å†…å®¹é¢„è§ˆï¼šè¢«å›å¤æ¶ˆæ¯çš„é¢„è§ˆ
    #[prost(string, tag = "2")]
    pub quoted_content_preview: ::prost::alloc::string::String,
    /// å¼•ç”¨æ–‡æœ¬ï¼šå›å¤çš„æ–‡æœ¬å†…å®¹
    #[prost(string, tag = "3")]
    pub quote_text: ::prost::alloc::string::String,
}
/// ===============================
/// ğŸŒ HTML å¡ç‰‡
/// ===============================
/// ç”¨äºå¯Œæ–‡æœ¬å†…å®¹ï¼Œæ”¯æŒç½‘é¡µé“¾æ¥å’Œé¢„è§ˆ
#[derive(serde::Serialize, serde::Deserialize, utoipa::ToSchema)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HtmlContent {
    /// æ ‡é¢˜ï¼šå¡ç‰‡çš„æ ‡é¢˜
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    /// URLï¼šé“¾æ¥åœ°å€
    #[prost(string, tag = "2")]
    pub url: ::prost::alloc::string::String,
    /// é¢„è§ˆï¼šå†…å®¹çš„é¢„è§ˆæ–‡æœ¬
    #[prost(string, tag = "3")]
    pub preview: ::prost::alloc::string::String,
}
/// ===============================
/// ğŸ“ VOIP é€šè¯è®°å½•
/// ===============================
/// ç”¨äºè®°å½•é€šè¯å†å²ï¼ŒåŒ…å«é€šè¯çš„åŸºæœ¬ä¿¡æ¯
#[derive(serde::Serialize, serde::Deserialize, utoipa::ToSchema)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VoipContent {
    /// ä¸»å« IDï¼šå‘èµ·é€šè¯çš„ç”¨æˆ·
    #[prost(string, tag = "1")]
    pub caller_id: ::prost::alloc::string::String,
    /// è¢«å« IDï¼šæ¥æ”¶é€šè¯çš„ç”¨æˆ·
    #[prost(string, tag = "2")]
    pub callee_id: ::prost::alloc::string::String,
    /// é€šè¯æ—¶é•¿ï¼ˆç§’ï¼‰ï¼šé€šè¯çš„æŒç»­æ—¶é—´
    #[prost(int64, tag = "3")]
    pub duration: i64,
    /// é€šè¯çŠ¶æ€ï¼šé€šè¯çš„ç»“æœçŠ¶æ€
    #[prost(string, tag = "4")]
    pub status: ::prost::alloc::string::String,
}
/// ===============================
/// ğŸ”” é€šçŸ¥æ¶ˆæ¯
/// ===============================
/// ç”¨äºç³»ç»Ÿé€šçŸ¥ï¼ŒåŒ…å«æ ‡é¢˜ã€å†…å®¹å’Œå…ƒæ•°æ®
#[derive(serde::Serialize, serde::Deserialize, utoipa::ToSchema)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NotificationContent {
    /// æ ‡é¢˜ï¼šé€šçŸ¥çš„æ ‡é¢˜
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    /// å†…å®¹ï¼šé€šçŸ¥çš„ä¸»ä½“å†…å®¹
    #[prost(string, tag = "2")]
    pub body: ::prost::alloc::string::String,
    /// å…ƒæ•°æ®ï¼šé€šçŸ¥çš„é™„åŠ ä¿¡æ¯
    #[prost(map = "string, string", tag = "3")]
    pub metadata: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
/// ===============================
/// âš™ï¸ ç³»ç»Ÿæ¶ˆæ¯
/// ===============================
/// ç”¨äºç³»ç»Ÿçº§æ¶ˆæ¯ï¼ŒåŒ…å«ç³»ç»Ÿä»£ç å’Œå†…å®¹
#[derive(serde::Serialize, serde::Deserialize, utoipa::ToSchema)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SystemContent {
    /// å†…å®¹ï¼šç³»ç»Ÿæ¶ˆæ¯çš„å†…å®¹
    #[prost(string, tag = "1")]
    pub content: ::prost::alloc::string::String,
    /// ä»£ç ï¼šç³»ç»Ÿæ¶ˆæ¯çš„ä»£ç æ ‡è¯†
    #[prost(string, tag = "2")]
    pub code: ::prost::alloc::string::String,
}
/// ===============================
/// â° æé†’äº‹é¡¹
/// ===============================
/// ç”¨äºæé†’åŠŸèƒ½ï¼ŒåŒ…å«æé†’æ–‡æœ¬å’Œæ—¶é—´
#[derive(serde::Serialize, serde::Deserialize, utoipa::ToSchema)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReminderContent {
    /// æ–‡æœ¬ï¼šæé†’çš„å†…å®¹
    #[prost(string, tag = "1")]
    pub text: ::prost::alloc::string::String,
    /// æé†’æ—¶é—´ï¼šæé†’è§¦å‘çš„æ—¶é—´æˆ³
    #[prost(int64, tag = "2")]
    pub remind_at: i64,
}
/// ===============================
/// ğŸ‘ª ç¾¤ç»„äº‹ä»¶
/// ===============================
/// ç”¨äºç¾¤ç»„ç›¸å…³äº‹ä»¶ï¼ŒåŒ…å«ç¾¤ç»„ä¿¡æ¯å’Œæ“ä½œè€…
#[derive(serde::Serialize, serde::Deserialize, utoipa::ToSchema)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GroupEventContent {
    /// ç¾¤ç»„ IDï¼šäº‹ä»¶ç›¸å…³çš„ç¾¤ç»„
    #[prost(string, tag = "1")]
    pub group_id: ::prost::alloc::string::String,
    /// äº‹ä»¶ï¼šäº‹ä»¶çš„å…·ä½“æè¿°
    #[prost(string, tag = "2")]
    pub event: ::prost::alloc::string::String,
    /// æ“ä½œè€… IDï¼šæ‰§è¡Œæ“ä½œçš„ç”¨æˆ·
    #[prost(string, tag = "3")]
    pub operator_id: ::prost::alloc::string::String,
}
/// ===============================
/// ğŸ“‡ åç‰‡æ¶ˆæ¯
/// ===============================
/// ç”¨äºåˆ†äº«è”ç³»äººä¿¡æ¯ï¼ŒåŒ…å«ç”¨æˆ·çš„åŸºæœ¬ä¿¡æ¯
#[derive(serde::Serialize, serde::Deserialize, utoipa::ToSchema)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ContactCardContent {
    /// ç›®æ ‡ IDï¼šè¢«åˆ†äº«ç”¨æˆ·çš„ID
    #[prost(string, tag = "1")]
    pub target_id: ::prost::alloc::string::String,
    /// æ˜¾ç¤ºåç§°ï¼šç”¨æˆ·çš„æ˜¾ç¤ºåç§°
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    /// å¤´åƒ URLï¼šç”¨æˆ·çš„å¤´åƒåœ°å€
    #[prost(string, tag = "3")]
    pub avatar_url: ::prost::alloc::string::String,
    /// å¡ç‰‡ç±»å‹ï¼šåç‰‡çš„ç±»å‹ï¼ˆç”¨æˆ·/ç¾¤ç»„ï¼‰
    #[prost(string, tag = "4")]
    pub card_type: ::prost::alloc::string::String,
}
/// ===============================
/// ğŸ“Š æŠ•ç¥¨æ¶ˆæ¯
/// ===============================
/// ç”¨äºç¾¤ç»„æŠ•ç¥¨åŠŸèƒ½ï¼ŒåŒ…å«æŠ•ç¥¨é€‰é¡¹å’Œç»“æœ
#[derive(serde::Serialize, serde::Deserialize, utoipa::ToSchema)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VoteContent {
    /// ä¸»é¢˜ï¼šæŠ•ç¥¨çš„ä¸»é¢˜
    #[prost(string, tag = "1")]
    pub topic: ::prost::alloc::string::String,
    /// é€‰é¡¹ï¼šæŠ•ç¥¨çš„é€‰é¡¹åˆ—è¡¨
    #[prost(string, repeated, tag = "2")]
    pub options: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// ç»“æœï¼šæŠ•ç¥¨ç»“æœç»Ÿè®¡
    #[prost(map = "string, int32", tag = "3")]
    pub result: ::std::collections::HashMap<::prost::alloc::string::String, i32>,
    /// å¤šé€‰ï¼šæ˜¯å¦å…è®¸å¤šé€‰
    #[prost(bool, tag = "4")]
    pub multi_choice: bool,
}
/// ===============================
/// ğŸ’° çº¢åŒ…æ¶ˆæ¯
/// ===============================
/// ç”¨äºçº¢åŒ…åŠŸèƒ½ï¼ŒåŒ…å«çº¢åŒ…é‡‘é¢å’ŒçŠ¶æ€
#[derive(serde::Serialize, serde::Deserialize, utoipa::ToSchema)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RedEnvelopeContent {
    /// å‘é€è€… IDï¼šçº¢åŒ…å‘é€è€…
    #[prost(string, tag = "1")]
    pub sender_id: ::prost::alloc::string::String,
    /// é‡‘é¢ï¼šçº¢åŒ…é‡‘é¢ï¼ˆåˆ†ï¼‰
    #[prost(int32, tag = "2")]
    pub amount: i32,
    /// ç¥ç¦è¯­ï¼šçº¢åŒ…çš„ç¥ç¦è¯­
    #[prost(string, tag = "3")]
    pub blessing: ::prost::alloc::string::String,
    /// æ˜¯å¦å·²é¢†å–ï¼šçº¢åŒ…æ˜¯å¦å·²è¢«é¢†å–
    #[prost(bool, tag = "4")]
    pub claimed: bool,
}
/// ======================================
/// âœ‚ï¸ Segment - æ¶ˆæ¯æ®µç»“æ„ï¼ˆç”¨äºå¤åˆå†…å®¹ï¼‰
/// ======================================
/// è¡¨ç¤ºä¸€æ¡æ¶ˆæ¯ä¸­çš„ä¸€ä¸ªç‹¬ç«‹æ®µï¼ˆå¦‚æ–‡æœ¬æ®µã€å›¾ç‰‡æ®µç­‰ï¼‰ï¼Œæ”¯æŒæ’åºã€ç¼–è¾‘ã€æ ‡è®°ç­‰
#[derive(serde::Serialize, serde::Deserialize, utoipa::ToSchema)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Segment {
    /// æ¶ˆæ¯æ®µå†…å®¹ï¼ˆå¦‚æ–‡æœ¬ã€å›¾ç‰‡ç­‰ï¼Œä½¿ç”¨ oneof å°è£…ï¼‰ï¼šæ®µçš„å…·ä½“å†…å®¹
    #[prost(message, optional, tag = "1")]
    pub body: ::core::option::Option<MessageContent>,
    /// æ®µå”¯ä¸€æ ‡è¯†ï¼ˆå®¢æˆ·ç«¯ç”Ÿæˆæˆ–æœåŠ¡ç«¯è¡¥å…¨ï¼‰ï¼šæ®µçš„å”¯ä¸€ID
    #[prost(string, tag = "2")]
    pub segment_id: ::prost::alloc::string::String,
    /// æ¶ˆæ¯å†…é¡ºåºç¼–å·ï¼ˆç”¨äºå‰ç«¯æ¸²æŸ“æ’åºï¼‰ï¼šæ®µåœ¨æ¶ˆæ¯ä¸­çš„é¡ºåº
    #[prost(uint64, tag = "3")]
    pub seq_in_msg: u64,
    /// æ˜¯å¦ä¸ºç¼–è¾‘åçš„æ®µè½ï¼ˆtrue è¡¨ç¤ºè¢«ä¿®æ”¹ï¼‰ï¼šæ®µçš„ç¼–è¾‘çŠ¶æ€
    #[prost(bool, tag = "4")]
    pub edited: bool,
    /// æ˜¯å¦å…è®¸å®¢æˆ·ç«¯æ¸²æŸ“è¯¥æ®µï¼ˆfalse å¯ç”¨äºéšè—è‰ç¨¿ç­‰ï¼‰ï¼šæ®µçš„å¯è§æ€§
    #[prost(bool, tag = "5")]
    pub visible: bool,
    /// é€šç”¨æ‰©å±•å­—æ®µï¼ˆä»¥å­—ç¬¦ä¸²é”®å€¼å¯¹å­˜å‚¨ JSON æ‰å¹³æ•°æ®ï¼‰ï¼šæ®µçš„å…ƒæ•°æ®
    #[prost(map = "string, string", tag = "6")]
    pub metadata: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
/// ======================================
/// ğŸ“¨ é¡¶å±‚æ¶ˆæ¯ç»“æ„
/// ======================================
/// å®šä¹‰äº†æ¶ˆæ¯çš„åŸºæœ¬æ¡†æ¶ï¼ŒåŒ…å«å‘é€è€…ã€æ¥æ”¶è€…ã€æ—¶é—´ç­‰å…ƒæ•°æ®
#[derive(serde::Serialize, serde::Deserialize, utoipa::ToSchema)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Content {
    /// å”¯ä¸€æ¶ˆæ¯ IDï¼ˆå®¢æˆ·ç«¯ç”Ÿæˆæˆ–æœåŠ¡ç«¯è¡¥å…¨ï¼‰ï¼šæ¶ˆæ¯çš„å”¯ä¸€æ ‡è¯†
    #[prost(uint64, optional, tag = "1")]
    pub message_id: ::core::option::Option<u64>,
    /// æ¶ˆæ¯å‘é€æ–¹ï¼šå‘é€æ¶ˆæ¯çš„ç”¨æˆ·ID
    #[prost(string, tag = "2")]
    pub sender_id: ::prost::alloc::string::String,
    /// æ¶ˆæ¯æ¥æ”¶æ–¹ï¼ˆå•èŠä¸ºå¯¹æ–¹ IDï¼Œç¾¤èŠä¸ºç¾¤ IDï¼‰ï¼šæ¥æ”¶æ¶ˆæ¯çš„ç›®æ ‡
    #[prost(string, tag = "3")]
    pub receiver_id: ::prost::alloc::string::String,
    /// æ¶ˆæ¯å‘é€æ—¶é—´ï¼ˆæ¯«ç§’æ—¶é—´æˆ³ï¼‰ï¼šæ¶ˆæ¯åˆ›å»ºçš„æ—¶é—´
    #[prost(int64, tag = "4")]
    pub timestamp: i64,
    /// ä¸»æ¶ˆæ¯ç±»å‹ï¼ˆç”¨äºå¿«é€Ÿæ¸²æŸ“åˆ¤æ–­ï¼‰ï¼šæ¶ˆæ¯çš„ä¸»è¦ç±»å‹
    #[prost(enumeration = "super::super::common::ContentType", tag = "5")]
    pub message_type: i32,
    /// æ¶ˆæ¯æ‰€å±ä¼šè¯ç±»å‹ï¼ˆå•èŠ/ç¾¤èŠï¼‰ï¼šæ¶ˆæ¯çš„ä¼šè¯åœºæ™¯
    #[prost(enumeration = "ChatScene", tag = "6")]
    pub scene: i32,
    /// å¤šæ®µå¤åˆå†…å®¹ï¼ˆå¦‚æ–‡æœ¬ + å›¾ç‰‡ï¼‰ï¼šæ¶ˆæ¯çš„å…·ä½“å†…å®¹
    #[prost(message, repeated, tag = "10")]
    pub contents: ::prost::alloc::vec::Vec<MessageContent>,
}
/// ======================================
/// ğŸ’¬ ä¼šè¯åœºæ™¯ç±»å‹
/// ======================================
/// ç”¨äºæ ‡è¯†æ¶ˆæ¯æ‰€å±çš„ä¼šè¯ç±»å‹ï¼Œå¸®åŠ©å®¢æˆ·ç«¯è¿›è¡Œä¸åŒçš„æ¸²æŸ“å’Œå¤„ç†
#[derive(serde::Serialize, serde::Deserialize, utoipa::ToSchema)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ChatScene {
    /// é»˜è®¤æœªçŸ¥åœºæ™¯ï¼ˆé˜²å¾¡å€¼ï¼‰
    ChatUnknown = 0,
    /// å•äººä¼šè¯ï¼šç”¨æˆ·ä¸ç”¨æˆ·ä¹‹é—´çš„ç§èŠ
    Single = 1,
    /// ç¾¤èŠä¼šè¯ï¼šç¾¤ç»„å†…çš„å¤šäººèŠå¤©
    Group = 2,
}
impl ChatScene {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::ChatUnknown => "CHAT_UNKNOWN",
            Self::Single => "SINGLE",
            Self::Group => "GROUP",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CHAT_UNKNOWN" => Some(Self::ChatUnknown),
            "SINGLE" => Some(Self::Single),
            "GROUP" => Some(Self::Group),
            _ => None,
        }
    }
}
/// ======================================
/// ğŸ˜„ Emoji ç±»å‹å®šä¹‰ï¼ˆæ ‡å‡† + è‡ªå®šä¹‰ï¼‰
/// ======================================
/// å®šä¹‰äº†ç³»ç»Ÿä¸­æ”¯æŒçš„ emoji ç±»å‹ï¼ŒåŒ…æ‹¬æ ‡å‡† emoji å’Œè‡ªå®šä¹‰è¡¨æƒ…
#[derive(serde::Serialize, serde::Deserialize, utoipa::ToSchema)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EmojiType {
    EmojiUnknown = 0,
    /// å¾®ç¬‘è¡¨æƒ…
    Smile = 1,
    /// å’§å˜´ç¬‘è¡¨æƒ…
    Grin = 2,
    /// æµæ³ªè¡¨æƒ…
    Tears = 3,
    /// åèˆŒå¤´è¡¨æƒ…
    StuckOutTongue = 4,
    /// é¼“æŒè¡¨æƒ…
    Clap = 25,
    /// ä¾¿ä¾¿è¡¨æƒ…
    Poop = 28,
    /// çˆ±å¿ƒè¡¨æƒ…
    Heart = 21,
    /// ... å¯ç»§ç»­æ‰©å±•æ ‡å‡† Emoji
    ///
    /// è‡ªå®šä¹‰è¡¨æƒ…ï¼ˆé€šè¿‡å›¾ç‰‡ URL æŒ‡å®šï¼‰
    CustomEmoji = 1000,
}
impl EmojiType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::EmojiUnknown => "EMOJI_UNKNOWN",
            Self::Smile => "SMILE",
            Self::Grin => "GRIN",
            Self::Tears => "TEARS",
            Self::StuckOutTongue => "STUCK_OUT_TONGUE",
            Self::Clap => "CLAP",
            Self::Poop => "POOP",
            Self::Heart => "HEART",
            Self::CustomEmoji => "CUSTOM_EMOJI",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "EMOJI_UNKNOWN" => Some(Self::EmojiUnknown),
            "SMILE" => Some(Self::Smile),
            "GRIN" => Some(Self::Grin),
            "TEARS" => Some(Self::Tears),
            "STUCK_OUT_TONGUE" => Some(Self::StuckOutTongue),
            "CLAP" => Some(Self::Clap),
            "POOP" => Some(Self::Poop),
            "HEART" => Some(Self::Heart),
            "CUSTOM_EMOJI" => Some(Self::CustomEmoji),
            _ => None,
        }
    }
}
