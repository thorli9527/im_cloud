// This file is @generated by prost-build.
/// ======================================
/// ğŸ“¨ é¡¶å±‚æ¶ˆæ¯ç»“æ„
/// ======================================
#[derive(serde::Serialize, serde::Deserialize, utoipa::ToSchema)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Message {
    /// å”¯ä¸€æ¶ˆæ¯ IDï¼ˆå®¢æˆ·ç«¯ç”Ÿæˆæˆ–æœåŠ¡ç«¯è¡¥å…¨ï¼‰
    #[prost(string, tag = "1")]
    pub message_id: ::prost::alloc::string::String,
    /// æ¶ˆæ¯å‘é€æ–¹
    #[prost(string, tag = "2")]
    pub sender_id: ::prost::alloc::string::String,
    /// æ¶ˆæ¯æ¥æ”¶æ–¹ï¼ˆå•èŠä¸ºå¯¹æ–¹ IDï¼Œç¾¤èŠä¸ºç¾¤ IDï¼‰
    #[prost(string, tag = "3")]
    pub receiver_id: ::prost::alloc::string::String,
    /// æ¶ˆæ¯å‘é€æ—¶é—´ï¼ˆæ¯«ç§’æ—¶é—´æˆ³ï¼‰
    #[prost(int64, tag = "4")]
    pub timestamp: i64,
    /// ä¸»æ¶ˆæ¯ç±»å‹ï¼ˆç”¨äºå¿«é€Ÿæ¸²æŸ“åˆ¤æ–­ï¼‰
    #[prost(enumeration = "super::common::MessageType", tag = "5")]
    pub message_type: i32,
    /// æ¶ˆæ¯æ‰€å±ä¼šè¯ç±»å‹ï¼ˆå•èŠ/ç¾¤èŠï¼‰
    #[prost(enumeration = "ChatScene", tag = "6")]
    pub scene: i32,
    /// å¤šæ®µå¤åˆå†…å®¹ï¼ˆå¦‚æ–‡æœ¬ + å›¾ç‰‡ï¼‰
    #[prost(message, repeated, tag = "10")]
    pub contents: ::prost::alloc::vec::Vec<MessageContent>,
}
/// ======================================
/// ğŸ’  æ¶ˆæ¯å†…å®¹ç»“æ„ï¼ˆoneof ç±»å‹ï¼‰
/// ======================================
#[derive(serde::Serialize, serde::Deserialize, utoipa::ToSchema)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MessageContent {
    #[prost(
        oneof = "message_content::Content",
        tags = "1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22"
    )]
    pub content: ::core::option::Option<message_content::Content>,
}
/// Nested message and enum types in `MessageContent`.
pub mod message_content {
    #[derive(serde::Serialize, serde::Deserialize, utoipa::ToSchema)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Content {
        #[prost(message, tag = "1")]
        Text(super::TextMessage),
        #[prost(message, tag = "2")]
        Image(super::ImageMessage),
        #[prost(message, tag = "3")]
        Audio(super::AudioMessage),
        #[prost(message, tag = "4")]
        Video(super::VideoMessage),
        #[prost(message, tag = "5")]
        Location(super::LocationMessage),
        #[prost(message, tag = "6")]
        File(super::FileMessage),
        #[prost(message, tag = "7")]
        AvCall(super::AvCallMessage),
        #[prost(message, tag = "8")]
        Custom(super::CustomMessage),
        #[prost(message, tag = "9")]
        Emoji(super::EmojiMessage),
        #[prost(message, tag = "10")]
        Revoke(super::RevokeMessage),
        #[prost(message, tag = "11")]
        Forward(super::ForwardMessage),
        #[prost(message, tag = "12")]
        Quote(super::QuoteMessage),
        #[prost(message, tag = "13")]
        Html(super::HtmlMessage),
        #[prost(message, tag = "14")]
        Voip(super::VoipMessage),
        #[prost(message, tag = "15")]
        Notification(super::NotificationMessage),
        #[prost(message, tag = "16")]
        System(super::SystemMessage),
        #[prost(message, tag = "17")]
        Reminder(super::ReminderMessage),
        #[prost(message, tag = "18")]
        FriendEvent(super::super::friend::FriendEventMessage),
        #[prost(message, tag = "19")]
        GroupEvent(super::GroupEventMessage),
        #[prost(message, tag = "20")]
        ContactCard(super::ContactCardMessage),
        #[prost(message, tag = "21")]
        Vote(super::VoteMessage),
        #[prost(message, tag = "22")]
        RedEnvelope(super::RedEnvelopeMessage),
    }
}
/// ===============================
/// ğŸ“„ æ–‡æœ¬æ¶ˆæ¯
/// ===============================
#[derive(serde::Serialize, serde::Deserialize, utoipa::ToSchema)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TextMessage {
    /// æ–‡æœ¬ä¸»ä½“å†…å®¹
    #[prost(string, tag = "1")]
    pub text: ::prost::alloc::string::String,
    /// å¯Œæ–‡æœ¬å®ä½“ï¼Œå¦‚é“¾æ¥/@ç”¨æˆ·/è¯é¢˜
    #[prost(message, repeated, tag = "2")]
    pub entities: ::prost::alloc::vec::Vec<InlineEntity>,
}
#[derive(serde::Serialize, serde::Deserialize, utoipa::ToSchema)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InlineEntity {
    /// èµ·å§‹ä½ç½®ï¼ˆUTF-8 å­—ç¬¦ç´¢å¼•ï¼‰
    #[prost(int32, tag = "1")]
    pub start: i32,
    /// ç»“æŸä½ç½®ï¼ˆä¸å«ï¼‰
    #[prost(int32, tag = "2")]
    pub end: i32,
    /// ç±»å‹ï¼šlink / mention / hashtag
    #[prost(string, tag = "3")]
    pub r#type: ::prost::alloc::string::String,
    /// é™„åŠ å€¼ï¼šURLã€ç”¨æˆ·IDç­‰
    #[prost(string, tag = "4")]
    pub value: ::prost::alloc::string::String,
}
/// ===============================
/// ğŸ–¼ï¸ å›¾ç‰‡æ¶ˆæ¯
/// ===============================
#[derive(serde::Serialize, serde::Deserialize, utoipa::ToSchema)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImageMessage {
    /// åŸå›¾ URL
    #[prost(string, tag = "1")]
    pub url: ::prost::alloc::string::String,
    /// ç¼©ç•¥å›¾ URL
    #[prost(string, tag = "2")]
    pub thumbnail_url: ::prost::alloc::string::String,
    /// å®½åº¦ï¼ˆåƒç´ ï¼‰
    #[prost(int32, tag = "3")]
    pub width: i32,
    /// é«˜åº¦ï¼ˆåƒç´ ï¼‰
    #[prost(int32, tag = "4")]
    pub height: i32,
    /// æ ¼å¼ï¼ˆå¦‚ jpg/pngï¼‰
    #[prost(string, tag = "5")]
    pub format: ::prost::alloc::string::String,
    /// æ–‡ä»¶å¤§å°ï¼ˆå­—èŠ‚ï¼‰
    #[prost(int64, tag = "6")]
    pub size: i64,
}
/// ===============================
/// ğŸ”Š éŸ³é¢‘æ¶ˆæ¯
/// ===============================
#[derive(serde::Serialize, serde::Deserialize, utoipa::ToSchema)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AudioMessage {
    #[prost(string, tag = "1")]
    pub url: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub duration: i32,
    #[prost(string, tag = "3")]
    pub format: ::prost::alloc::string::String,
    #[prost(int64, tag = "4")]
    pub size: i64,
    /// æ˜¯å¦è¯­éŸ³ï¼ˆvs éŸ³ä¹ç±»éŸ³é¢‘ï¼‰
    #[prost(bool, tag = "5")]
    pub is_voice: bool,
}
/// ===============================
/// ğŸï¸ è§†é¢‘æ¶ˆæ¯
/// ===============================
#[derive(serde::Serialize, serde::Deserialize, utoipa::ToSchema)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VideoMessage {
    #[prost(string, tag = "1")]
    pub url: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub duration: i32,
    #[prost(string, tag = "3")]
    pub cover_url: ::prost::alloc::string::String,
    #[prost(int32, tag = "4")]
    pub width: i32,
    #[prost(int32, tag = "5")]
    pub height: i32,
    #[prost(string, tag = "6")]
    pub format: ::prost::alloc::string::String,
    #[prost(int64, tag = "7")]
    pub size: i64,
}
/// ===============================
/// ğŸ“ ä½ç½®æ¶ˆæ¯
/// ===============================
#[derive(serde::Serialize, serde::Deserialize, utoipa::ToSchema)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LocationMessage {
    #[prost(double, tag = "1")]
    pub latitude: f64,
    #[prost(double, tag = "2")]
    pub longitude: f64,
    #[prost(string, tag = "3")]
    pub address: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub poi_name: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub thumbnail_url: ::prost::alloc::string::String,
}
/// ===============================
/// ğŸ“ æ–‡ä»¶æ¶ˆæ¯
/// ===============================
#[derive(serde::Serialize, serde::Deserialize, utoipa::ToSchema)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FileMessage {
    #[prost(string, tag = "1")]
    pub url: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    #[prost(int64, tag = "3")]
    pub size: i64,
    #[prost(string, tag = "4")]
    pub file_type: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub icon_url: ::prost::alloc::string::String,
}
/// ===============================
/// ğŸ“ éŸ³è§†é¢‘é€šè¯ä¿¡ä»¤
/// ===============================
#[derive(serde::Serialize, serde::Deserialize, utoipa::ToSchema)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AvCallMessage {
    #[prost(string, tag = "1")]
    pub call_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub initiator_id: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub participant_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(enumeration = "av_call_message::CallAction", tag = "4")]
    pub action: i32,
    #[prost(enumeration = "av_call_message::CallType", tag = "5")]
    pub r#type: i32,
    #[prost(int64, tag = "6")]
    pub timestamp: i64,
    #[prost(int32, tag = "7")]
    pub duration: i32,
}
/// Nested message and enum types in `AVCallMessage`.
pub mod av_call_message {
    #[derive(serde::Serialize, serde::Deserialize, utoipa::ToSchema)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CallAction {
        Unknown = 0,
        Invite = 1,
        Accept = 2,
        Reject = 3,
        Cancel = 4,
        End = 5,
        Timeout = 6,
    }
    impl CallAction {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "UNKNOWN",
                Self::Invite => "INVITE",
                Self::Accept => "ACCEPT",
                Self::Reject => "REJECT",
                Self::Cancel => "CANCEL",
                Self::End => "END",
                Self::Timeout => "TIMEOUT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNKNOWN" => Some(Self::Unknown),
                "INVITE" => Some(Self::Invite),
                "ACCEPT" => Some(Self::Accept),
                "REJECT" => Some(Self::Reject),
                "CANCEL" => Some(Self::Cancel),
                "END" => Some(Self::End),
                "TIMEOUT" => Some(Self::Timeout),
                _ => None,
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize, utoipa::ToSchema)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CallType {
        Audio = 0,
        Video = 1,
    }
    impl CallType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Audio => "AUDIO",
                Self::Video => "VIDEO",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "AUDIO" => Some(Self::Audio),
                "VIDEO" => Some(Self::Video),
                _ => None,
            }
        }
    }
}
/// ===============================
/// ğŸ’  è‡ªå®šä¹‰ç»“æ„åŒ–æ¶ˆæ¯
/// ===============================
#[derive(serde::Serialize, serde::Deserialize, utoipa::ToSchema)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomMessage {
    #[prost(string, tag = "1")]
    pub custom_type: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub json_payload: ::prost::alloc::string::String,
}
/// ===============================
/// ğŸ˜„ è¡¨æƒ…æ¶ˆæ¯
/// ===============================
#[derive(serde::Serialize, serde::Deserialize, utoipa::ToSchema)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EmojiMessage {
    #[prost(enumeration = "EmojiType", tag = "1")]
    pub emoji: i32,
    #[prost(string, tag = "2")]
    pub custom_emoji_url: ::prost::alloc::string::String,
}
/// ===============================
/// â›” æ’¤å›æ¶ˆæ¯
/// ===============================
#[derive(serde::Serialize, serde::Deserialize, utoipa::ToSchema)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RevokeMessage {
    #[prost(string, tag = "1")]
    pub target_message_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub operator_id: ::prost::alloc::string::String,
    #[prost(int64, tag = "3")]
    pub revoke_time: i64,
}
/// ===============================
/// ğŸ“¤ è½¬å‘æ¶ˆæ¯
/// ===============================
#[derive(serde::Serialize, serde::Deserialize, utoipa::ToSchema)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ForwardMessage {
    #[prost(string, tag = "1")]
    pub original_message_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub original_sender_id: ::prost::alloc::string::String,
    #[prost(enumeration = "super::common::MessageType", tag = "3")]
    pub original_type: i32,
    #[prost(string, tag = "4")]
    pub summary: ::prost::alloc::string::String,
}
/// ===============================
/// ğŸ“Œ å¼•ç”¨å›å¤æ¶ˆæ¯
/// ===============================
#[derive(serde::Serialize, serde::Deserialize, utoipa::ToSchema)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QuoteMessage {
    #[prost(string, tag = "1")]
    pub quoted_message_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub quoted_content_preview: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub quote_text: ::prost::alloc::string::String,
}
/// ===============================
/// ğŸŒ HTML å¡ç‰‡
/// ===============================
#[derive(serde::Serialize, serde::Deserialize, utoipa::ToSchema)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HtmlMessage {
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub url: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub preview: ::prost::alloc::string::String,
}
/// ===============================
/// ğŸ“ VOIP é€šè¯è®°å½•
/// ===============================
#[derive(serde::Serialize, serde::Deserialize, utoipa::ToSchema)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VoipMessage {
    #[prost(string, tag = "1")]
    pub caller_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub callee_id: ::prost::alloc::string::String,
    #[prost(int64, tag = "3")]
    pub duration: i64,
    #[prost(string, tag = "4")]
    pub status: ::prost::alloc::string::String,
}
/// ===============================
/// ğŸ”” é€šçŸ¥æ¶ˆæ¯
/// ===============================
#[derive(serde::Serialize, serde::Deserialize, utoipa::ToSchema)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NotificationMessage {
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub body: ::prost::alloc::string::String,
    #[prost(map = "string, string", tag = "3")]
    pub metadata: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
/// ===============================
/// âš™ï¸ ç³»ç»Ÿæ¶ˆæ¯
/// ===============================
#[derive(serde::Serialize, serde::Deserialize, utoipa::ToSchema)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SystemMessage {
    #[prost(string, tag = "1")]
    pub content: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub code: ::prost::alloc::string::String,
}
/// ===============================
/// â° æé†’äº‹é¡¹
/// ===============================
#[derive(serde::Serialize, serde::Deserialize, utoipa::ToSchema)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReminderMessage {
    #[prost(string, tag = "1")]
    pub text: ::prost::alloc::string::String,
    #[prost(int64, tag = "2")]
    pub remind_at: i64,
}
/// ===============================
/// ğŸ‘ª ç¾¤ç»„äº‹ä»¶
/// ===============================
#[derive(serde::Serialize, serde::Deserialize, utoipa::ToSchema)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GroupEventMessage {
    #[prost(string, tag = "1")]
    pub group_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub event: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub operator_id: ::prost::alloc::string::String,
}
/// ===============================
/// ğŸ“‡ åç‰‡æ¶ˆæ¯
/// ===============================
#[derive(serde::Serialize, serde::Deserialize, utoipa::ToSchema)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ContactCardMessage {
    #[prost(string, tag = "1")]
    pub target_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub avatar_url: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub card_type: ::prost::alloc::string::String,
}
/// ===============================
/// ğŸ“Š æŠ•ç¥¨æ¶ˆæ¯
/// ===============================
#[derive(serde::Serialize, serde::Deserialize, utoipa::ToSchema)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VoteMessage {
    #[prost(string, tag = "1")]
    pub topic: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub options: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(map = "string, int32", tag = "3")]
    pub result: ::std::collections::HashMap<::prost::alloc::string::String, i32>,
    #[prost(bool, tag = "4")]
    pub multi_choice: bool,
}
/// ===============================
/// ğŸ’° çº¢åŒ…æ¶ˆæ¯
/// ===============================
#[derive(serde::Serialize, serde::Deserialize, utoipa::ToSchema)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RedEnvelopeMessage {
    #[prost(string, tag = "1")]
    pub sender_id: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub amount: i32,
    #[prost(string, tag = "3")]
    pub blessing: ::prost::alloc::string::String,
    #[prost(bool, tag = "4")]
    pub claimed: bool,
}
/// ======================================
/// âœ‚ï¸ Segment - æ¶ˆæ¯æ®µç»“æ„ï¼ˆç”¨äºå¤åˆå†…å®¹ï¼‰
/// ======================================
/// è¡¨ç¤ºä¸€æ¡æ¶ˆæ¯ä¸­çš„ä¸€ä¸ªç‹¬ç«‹æ®µï¼ˆå¦‚æ–‡æœ¬æ®µã€å›¾ç‰‡æ®µç­‰ï¼‰ï¼Œæ”¯æŒæ’åºã€ç¼–è¾‘ã€æ ‡è®°ç­‰
#[derive(serde::Serialize, serde::Deserialize, utoipa::ToSchema)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Segment {
    /// æ¶ˆæ¯æ®µå†…å®¹ï¼ˆå¦‚æ–‡æœ¬ã€å›¾ç‰‡ç­‰ï¼Œä½¿ç”¨ oneof å°è£…ï¼‰
    #[prost(message, optional, tag = "1")]
    pub body: ::core::option::Option<MessageContent>,
    /// æ®µå”¯ä¸€æ ‡è¯†ï¼ˆå®¢æˆ·ç«¯ç”Ÿæˆæˆ–æœåŠ¡ç«¯è¡¥å…¨ï¼‰
    #[prost(string, tag = "2")]
    pub segment_id: ::prost::alloc::string::String,
    /// æ¶ˆæ¯å†…é¡ºåºç¼–å·ï¼ˆç”¨äºå‰ç«¯æ¸²æŸ“æ’åºï¼‰
    #[prost(uint64, tag = "3")]
    pub seq_in_msg: u64,
    /// æ˜¯å¦ä¸ºç¼–è¾‘åçš„æ®µè½ï¼ˆtrue è¡¨ç¤ºè¢«ä¿®æ”¹ï¼‰
    #[prost(bool, tag = "4")]
    pub edited: bool,
    /// æ˜¯å¦å…è®¸å®¢æˆ·ç«¯æ¸²æŸ“è¯¥æ®µï¼ˆfalse å¯ç”¨äºéšè—è‰ç¨¿ç­‰ï¼‰
    #[prost(bool, tag = "5")]
    pub visible: bool,
    /// é€šç”¨æ‰©å±•å­—æ®µï¼ˆä»¥å­—ç¬¦ä¸²é”®å€¼å¯¹å­˜å‚¨ JSON æ‰å¹³æ•°æ®ï¼‰
    #[prost(map = "string, string", tag = "6")]
    pub metadata: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
/// ======================================
/// ğŸ’¬ ä¼šè¯åœºæ™¯ç±»å‹
/// ======================================
#[derive(serde::Serialize, serde::Deserialize, utoipa::ToSchema)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ChatScene {
    /// é»˜è®¤æœªçŸ¥åœºæ™¯ï¼ˆé˜²å¾¡å€¼ï¼‰
    ChatUnknown = 0,
    /// å•äººä¼šè¯
    Single = 1,
    /// ç¾¤èŠä¼šè¯
    Group = 2,
}
impl ChatScene {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::ChatUnknown => "CHAT_UNKNOWN",
            Self::Single => "SINGLE",
            Self::Group => "GROUP",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CHAT_UNKNOWN" => Some(Self::ChatUnknown),
            "SINGLE" => Some(Self::Single),
            "GROUP" => Some(Self::Group),
            _ => None,
        }
    }
}
/// ======================================
/// ğŸ˜„ Emoji ç±»å‹å®šä¹‰ï¼ˆæ ‡å‡† + è‡ªå®šä¹‰ï¼‰
/// ======================================
#[derive(serde::Serialize, serde::Deserialize, utoipa::ToSchema)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EmojiType {
    EmojiUnknown = 0,
    Smile = 1,
    Grin = 2,
    Tears = 3,
    StuckOutTongue = 4,
    Clap = 25,
    Poop = 28,
    Heart = 21,
    /// ... å¯ç»§ç»­æ‰©å±•æ ‡å‡† Emoji
    ///
    /// è‡ªå®šä¹‰è¡¨æƒ…ï¼ˆé€šè¿‡å›¾ç‰‡ URL æŒ‡å®šï¼‰
    CustomEmoji = 1000,
}
impl EmojiType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::EmojiUnknown => "EMOJI_UNKNOWN",
            Self::Smile => "SMILE",
            Self::Grin => "GRIN",
            Self::Tears => "TEARS",
            Self::StuckOutTongue => "STUCK_OUT_TONGUE",
            Self::Clap => "CLAP",
            Self::Poop => "POOP",
            Self::Heart => "HEART",
            Self::CustomEmoji => "CUSTOM_EMOJI",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "EMOJI_UNKNOWN" => Some(Self::EmojiUnknown),
            "SMILE" => Some(Self::Smile),
            "GRIN" => Some(Self::Grin),
            "TEARS" => Some(Self::Tears),
            "STUCK_OUT_TONGUE" => Some(Self::StuckOutTongue),
            "CLAP" => Some(Self::Clap),
            "POOP" => Some(Self::Poop),
            "HEART" => Some(Self::Heart),
            "CUSTOM_EMOJI" => Some(Self::CustomEmoji),
            _ => None,
        }
    }
}
