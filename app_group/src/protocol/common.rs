// This file is @generated by prost-build.
/// *
/// é€šç”¨å“åº”ç»“æ„
#[derive(serde::Serialize, serde::Deserialize, utoipa::ToSchema)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CommonResp {
    /// æ˜¯å¦æˆåŠŸ
    #[prost(bool, tag = "1")]
    pub success: bool,
    /// é”™è¯¯æˆ–æç¤ºä¿¡æ¯
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
}
/// *
/// ç¾¤æ ‡ç­¾ä¿¡æ¯
#[derive(serde::Serialize, serde::Deserialize, utoipa::ToSchema)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TagInfo {
    /// æ ‡ç­¾å”¯ä¸€ID
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// æ ‡ç­¾åç§°
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// æ ‡ç­¾è¯´æ˜
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    /// å¯é€‰é¢œè‰²ä»£ç ï¼ˆå¦‚ "#FF0000"ï¼‰
    #[prost(string, tag = "4")]
    pub color: ::prost::alloc::string::String,
}
/// *
/// ç¾¤ç»„åŸºæœ¬ä¿¡æ¯ï¼ˆç”¨äºå±•ç¤ºå’Œé…ç½®ï¼‰
#[derive(serde::Serialize, serde::Deserialize, utoipa::ToSchema)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GroupEntity {
    /// ç¾¤ç»„å”¯ä¸€IDï¼ˆç”±ç³»ç»Ÿç”Ÿæˆï¼‰
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// ç¾¤ç»„åç§°ï¼ˆç”¨æˆ·å¯è§ï¼‰
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// ç¾¤å¤´åƒURL
    #[prost(string, tag = "3")]
    pub avatar: ::prost::alloc::string::String,
    /// ç¾¤ç®€ä»‹ï¼ˆæ”¯æŒå¯Œæ–‡æœ¬ï¼‰
    #[prost(string, tag = "4")]
    pub description: ::prost::alloc::string::String,
    /// ç¾¤å…¬å‘Šï¼ˆç¾¤æˆå‘˜å¯è§ï¼‰
    #[prost(string, tag = "5")]
    pub notice: ::prost::alloc::string::String,
    /// åŠ ç¾¤æƒé™æ§åˆ¶
    #[prost(enumeration = "JoinPermission", tag = "6")]
    pub join_permission: i32,
    /// ç¾¤æ ‡ç­¾ï¼ˆè‹±æ–‡é€—å·åˆ†éš”ï¼‰
    #[prost(string, tag = "7")]
    pub owner_id: ::prost::alloc::string::String,
    /// ç¾¤ç»„ç±»å‹ï¼š0 æ™®é€šç¾¤ / 1 è¶…çº§ç¾¤ / 2 ç³»ç»Ÿç¾¤
    #[prost(int32, tag = "8")]
    pub group_type: i32,
    /// æ˜¯å¦å…è®¸é€šè¿‡æœç´¢æ‰¾åˆ°
    #[prost(bool, tag = "9")]
    pub allow_search: bool,
    /// æ˜¯å¦å¯ç”¨
    #[prost(bool, tag = "10")]
    pub enable: bool,
    /// åˆ›å»ºæ—¶é—´
    #[prost(uint64, tag = "11")]
    pub create_time: u64,
    /// æ›´æ–°æ—¶é—´
    #[prost(uint64, tag = "12")]
    pub update_time: u64,
}
/// *
/// ç¾¤ç»„æˆå‘˜è¯¦ç»†ä¿¡æ¯
#[derive(serde::Serialize, serde::Deserialize, utoipa::ToSchema)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GroupMemberEntity {
    /// æˆå‘˜è®°å½•IDï¼ˆå†…éƒ¨æŒä¹…åŒ–ç”¨ï¼‰
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// æ‰€å±ç¾¤ç»„ID
    #[prost(string, tag = "2")]
    pub group_id: ::prost::alloc::string::String,
    /// ç”¨æˆ·å”¯ä¸€ID
    #[prost(string, tag = "3")]
    pub uid: ::prost::alloc::string::String,
    /// ç¾¤å†…åˆ«å / æ˜µç§°
    #[prost(string, tag = "4")]
    pub alias: ::prost::alloc::string::String,
    /// æˆå‘˜è§’è‰²
    #[prost(enumeration = "GroupRoleType", tag = "5")]
    pub role: i32,
    /// æ˜¯å¦ç¦è¨€ä¸­ï¼ˆtrue=è¢«ç¦è¨€ï¼‰
    #[prost(bool, tag = "6")]
    pub is_muted: bool,
    /// æˆå‘˜å¤´åƒURLï¼ˆå‰ç«¯å±•ç¤ºç”¨ï¼‰
    #[prost(string, tag = "7")]
    pub avatar: ::prost::alloc::string::String,
    /// åŠ å…¥æ—¶é—´
    #[prost(uint64, tag = "8")]
    pub create_time: u64,
    /// æ›´æ–°æ—¶é—´
    #[prost(uint64, tag = "9")]
    pub update_time: u64,
}
/// ==========================
/// ğŸ‘¤ å®¢æˆ·ç«¯ç”¨æˆ·å®ä½“å®šä¹‰
/// ==========================
#[derive(serde::Serialize, serde::Deserialize, utoipa::ToSchema)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClientEntity {
    /// ç”¨æˆ· ID
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// å§“å
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// ç”¨æˆ·å
    #[prost(string, tag = "3")]
    pub username: ::prost::alloc::string::String,
    /// å¯†ç 
    #[prost(string, tag = "4")]
    pub password: ::prost::alloc::string::String,
    /// å®¢æˆ·ç«¯ç”¨æˆ· ID
    #[prost(string, tag = "5")]
    pub uid: ::prost::alloc::string::String,
    /// æ˜¯å¦å¯ç”¨ï¼ˆå°å·ï¼‰
    #[prost(bool, tag = "6")]
    pub enable: bool,
    /// æ˜¯å¦é”å®šï¼ˆç¦æ­¢ç™»å½•ï¼‰
    #[prost(bool, tag = "7")]
    pub lock: bool,
    /// å¤´åƒ URLï¼ˆå¯é€‰ï¼Œç©ºå­—ç¬¦ä¸²è¡¨ç¤ºæ— ï¼‰
    #[prost(string, tag = "8")]
    pub avatar: ::prost::alloc::string::String,
    /// åŠ å¥½å‹ç­–ç•¥
    #[prost(enumeration = "FriendPolicy", tag = "9")]
    pub allow_add_friend: i32,
    /// ç”¨æˆ·åŸºæœ¬ä¿¡æ¯å­—æ®µï¼ˆKVï¼‰
    #[prost(map = "string, string", tag = "10")]
    pub profile_fields: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// æ‰©å±•å­—æ®µï¼ˆKVï¼Œå¯ä¸ºç©ºï¼‰
    #[prost(map = "string, string", tag = "11")]
    pub extend_fields: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// åˆ›å»ºæ—¶é—´ï¼ˆUnix ç§’ï¼‰
    #[prost(uint64, tag = "99")]
    pub create_time: u64,
    /// æœ€åæ›´æ–°æ—¶é—´ï¼ˆUnix ç§’ï¼‰
    #[prost(uint64, tag = "100")]
    pub update_time: u64,
}
/// *
/// ç¾¤æˆå‘˜è§’è‰²ç±»å‹
#[derive(serde::Serialize, serde::Deserialize, utoipa::ToSchema)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum GroupRoleType {
    /// ç¾¤ä¸»ï¼ˆæ‹¥æœ‰æœ€é«˜æƒé™ï¼‰
    Owner = 0,
    /// ç®¡ç†å‘˜ï¼ˆå…·å¤‡éƒ¨åˆ†ç®¡ç†æƒé™ï¼‰
    Admin = 1,
    /// æ™®é€šæˆå‘˜
    Member = 2,
}
impl GroupRoleType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Owner => "OWNER",
            Self::Admin => "ADMIN",
            Self::Member => "MEMBER",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "OWNER" => Some(Self::Owner),
            "ADMIN" => Some(Self::Admin),
            "MEMBER" => Some(Self::Member),
            _ => None,
        }
    }
}
/// *
/// åŠ ç¾¤æƒé™æ§åˆ¶ç±»å‹
#[derive(serde::Serialize, serde::Deserialize, utoipa::ToSchema)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum JoinPermission {
    /// ä»»ä½•äººéƒ½å¯åŠ å…¥
    Anyone = 0,
    /// åŠ ç¾¤éœ€å®¡æ‰¹
    NeedApproval = 1,
    /// ä»…å…è®¸é€šè¿‡é‚€è¯·åŠ å…¥
    InviteOnly = 2,
    /// ä¸å…è®¸åŠ å…¥
    Closed = 3,
}
impl JoinPermission {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Anyone => "ANYONE",
            Self::NeedApproval => "NEED_APPROVAL",
            Self::InviteOnly => "INVITE_ONLY",
            Self::Closed => "CLOSED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ANYONE" => Some(Self::Anyone),
            "NEED_APPROVAL" => Some(Self::NeedApproval),
            "INVITE_ONLY" => Some(Self::InviteOnly),
            "CLOSED" => Some(Self::Closed),
            _ => None,
        }
    }
}
/// *
/// åŠ ç¾¤éªŒè¯ç±»å‹
#[derive(serde::Serialize, serde::Deserialize, utoipa::ToSchema)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum JoinQuestionType {
    /// æ— éªŒè¯
    None = 0,
    /// ç­”é¢˜éªŒè¯
    Question = 1,
    /// éªŒè¯ç éªŒè¯
    Captcha = 2,
    /// é‚€è¯·ç éªŒè¯
    InviteCode = 3,
}
impl JoinQuestionType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "NONE",
            Self::Question => "QUESTION",
            Self::Captcha => "CAPTCHA",
            Self::InviteCode => "INVITE_CODE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "NONE" => Some(Self::None),
            "QUESTION" => Some(Self::Question),
            "CAPTCHA" => Some(Self::Captcha),
            "INVITE_CODE" => Some(Self::InviteCode),
            _ => None,
        }
    }
}
/// ======================================
/// ğŸ’¬ æ¶ˆæ¯ç±»å‹æšä¸¾ï¼ˆç”¨äºæ ‡è®°ä¸»æ¶ˆæ¯ç±»å‹ï¼‰
/// ======================================
/// æ¯æ¡æ¶ˆæ¯å°†æ ¹æ®å…¶ä¸»å†…å®¹èµ‹äºˆä¸€ä¸ªä¸»ç±»å‹ï¼Œä¾¿äºå‰ç«¯æ¸²æŸ“å’Œåç«¯åˆ†ç±»å¤„ç†ã€‚
/// æ³¨æ„ï¼šå…·ä½“å†…å®¹ä»ä»¥ MessageContent çš„ oneof å®ä½“ä¸ºå‡†ï¼ŒContentType ä»…ä¸ºç´¢å¼•åˆ†ç±»ç”¨é€”ã€‚
#[derive(serde::Serialize, serde::Deserialize, utoipa::ToSchema)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ContentType {
    /// æœªçŸ¥ç±»å‹ï¼šé»˜è®¤å€¼ï¼Œç”¨äºé˜²å¾¡æ€§å¤„ç†æˆ–è§£æå¤±è´¥æƒ…å†µ
    Unknown = 0,
    /// æ–‡æœ¬æ¶ˆæ¯ï¼šçº¯æ–‡æœ¬å†…å®¹
    Text = 1,
    /// å›¾ç‰‡æ¶ˆæ¯ï¼šåŒ…å«å›¾ç‰‡åœ°å€ã€å°ºå¯¸ã€ç¼©ç•¥å›¾ç­‰ä¿¡æ¯
    Image = 2,
    /// éŸ³é¢‘æ¶ˆæ¯ï¼šè¯­éŸ³èŠå¤©æˆ–è¯­éŸ³ç•™è¨€
    Audio = 3,
    /// è§†é¢‘æ¶ˆæ¯ï¼šæ’­æ”¾åœ°å€ã€å°é¢å›¾ã€æ—¶é•¿ç­‰
    Video = 4,
    /// HTML å¯Œæ–‡æœ¬æ¶ˆæ¯ï¼šç”¨äºç»“æ„åŒ–å¡ç‰‡ã€ç½‘é¡µé“¾æ¥ç­‰
    Html = 5,
    /// ä½ç½®æ¶ˆæ¯ï¼šç»çº¬åº¦ã€åœ°å€æè¿°ç­‰
    Location = 6,
    /// æ–‡ä»¶æ¶ˆæ¯ï¼šæ”¯æŒä»»æ„æ–‡ä»¶æ ¼å¼ï¼Œå¦‚ PDFã€Wordã€ZIP ç­‰
    File = 7,
    /// è¡¨æƒ…æ¶ˆæ¯ï¼šæ ‡å‡† emoji æˆ–è‡ªå®šä¹‰åŠ¨æ€/é™æ€è¡¨æƒ…
    Emoji = 8,
    /// å¼•ç”¨æ¶ˆæ¯ï¼šå¼•ç”¨å†å²æ¶ˆæ¯çš„å†…å®¹å¹¶é™„åŠ å›å¤
    Quote = 9,
    /// éŸ³è§†é¢‘é€šè¯ä¿¡ä»¤ï¼šå¦‚é‚€è¯·ã€æ¥å¬ã€æŒ‚æ–­ç­‰
    AvCall = 10,
    /// VOIP é€šè¯è®°å½•ï¼šç”¨äºä¿å­˜é€šè¯æ—¥å¿—
    Voip = 11,
    /// é€šçŸ¥æ¶ˆæ¯ï¼šç³»ç»Ÿæ¨é€æç¤ºã€å…¬å‘Šç­‰
    Notification = 12,
    /// ç³»ç»Ÿæ¶ˆæ¯ï¼šå¦‚å°å·ã€å¼ºåˆ¶ä¸‹çº¿ã€æœåŠ¡å™¨ç»´æŠ¤é€šçŸ¥ç­‰
    System = 13,
    /// æé†’æ¶ˆæ¯ï¼šå¦‚ä»£åŠäº‹é¡¹ã€æ—¥ç¨‹æé†’ç­‰
    Reminder = 14,
    /// å¥½å‹äº‹ä»¶ï¼šåŠ å¥½å‹ã€è¢«åˆ é™¤ã€æ‹‰é»‘ç­‰äº‹ä»¶
    FriendEvent = 15,
    /// ç¾¤ç»„äº‹ä»¶ï¼šå¦‚è¢«è¸¢å‡ºç¾¤ã€ç¾¤è§£æ•£ã€ç®¡ç†å‘˜å˜æ›´ç­‰
    GroupEvent = 16,
    /// æ¶ˆæ¯æ’¤å›ï¼šé€šçŸ¥å®¢æˆ·ç«¯æŸæ¡æ¶ˆæ¯å·²è¢«æ’¤å›
    Revoke = 17,
    /// è½¬å‘æ¶ˆæ¯ï¼šå¼•ç”¨å…¶ä»–æ¶ˆæ¯çš„å¤ç”¨/è½¬å‘ç‰ˆæœ¬
    Forward = 18,
    /// å¯é€‰æ‰©å±•ç±»å‹ï¼ˆæ ¹æ®ä¸šåŠ¡éœ€è¦æ·»åŠ ï¼‰
    ///
    /// åç‰‡æ¶ˆæ¯ï¼šç”¨æˆ·æˆ–ç¾¤çš„è”ç³»äººåˆ†äº«
    ContactCard = 19,
    /// æŠ•ç¥¨æ¶ˆæ¯ï¼šåŒ…å«æŠ•ç¥¨æ ‡é¢˜ã€é€‰é¡¹ã€ç»“æœç­‰ä¿¡æ¯
    Vote = 20,
    /// çº¢åŒ…æ¶ˆæ¯ï¼šç”¨äºèŠ‚æ—¥ã€ç¦åˆ©ç­‰åœºæ™¯
    RedEnvelope = 21,
    /// è‡ªå®šä¹‰æ¶ˆæ¯ï¼šå¼€å‘è€…è‡ªå®šä¹‰ç»“æ„ï¼Œé€šå¸¸ä»¥ JSON æ‰¿è½½
    Custom = 100,
}
impl ContentType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "UNKNOWN",
            Self::Text => "TEXT",
            Self::Image => "IMAGE",
            Self::Audio => "AUDIO",
            Self::Video => "VIDEO",
            Self::Html => "HTML",
            Self::Location => "LOCATION",
            Self::File => "FILE",
            Self::Emoji => "EMOJI",
            Self::Quote => "QUOTE",
            Self::AvCall => "AV_CALL",
            Self::Voip => "VOIP",
            Self::Notification => "NOTIFICATION",
            Self::System => "SYSTEM",
            Self::Reminder => "REMINDER",
            Self::FriendEvent => "FRIEND_EVENT",
            Self::GroupEvent => "GROUP_EVENT",
            Self::Revoke => "REVOKE",
            Self::Forward => "FORWARD",
            Self::ContactCard => "CONTACT_CARD",
            Self::Vote => "VOTE",
            Self::RedEnvelope => "RED_ENVELOPE",
            Self::Custom => "CUSTOM",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNKNOWN" => Some(Self::Unknown),
            "TEXT" => Some(Self::Text),
            "IMAGE" => Some(Self::Image),
            "AUDIO" => Some(Self::Audio),
            "VIDEO" => Some(Self::Video),
            "HTML" => Some(Self::Html),
            "LOCATION" => Some(Self::Location),
            "FILE" => Some(Self::File),
            "EMOJI" => Some(Self::Emoji),
            "QUOTE" => Some(Self::Quote),
            "AV_CALL" => Some(Self::AvCall),
            "VOIP" => Some(Self::Voip),
            "NOTIFICATION" => Some(Self::Notification),
            "SYSTEM" => Some(Self::System),
            "REMINDER" => Some(Self::Reminder),
            "FRIEND_EVENT" => Some(Self::FriendEvent),
            "GROUP_EVENT" => Some(Self::GroupEvent),
            "REVOKE" => Some(Self::Revoke),
            "FORWARD" => Some(Self::Forward),
            "CONTACT_CARD" => Some(Self::ContactCard),
            "VOTE" => Some(Self::Vote),
            "RED_ENVELOPE" => Some(Self::RedEnvelope),
            "CUSTOM" => Some(Self::Custom),
            _ => None,
        }
    }
}
/// ======================================
/// ğŸ¯ èŠå¤©ç›®æ ‡ç±»å‹æšä¸¾
/// ======================================
/// ç”¨äºæ ‡è¯†æ¶ˆæ¯çš„æ¥æ”¶ç›®æ ‡ç±»å‹ï¼Œå¸®åŠ©å®¢æˆ·ç«¯å’ŒæœåŠ¡ç«¯è¿›è¡Œä¸åŒçš„å¤„ç†é€»è¾‘
#[derive(serde::Serialize, serde::Deserialize, utoipa::ToSchema)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ChatTargetType {
    /// æœªçŸ¥ç±»å‹ï¼šé»˜è®¤å€¼ï¼Œç”¨äºé˜²å¾¡æ€§å¤„ç†æˆ–è§£æå¤±è´¥æƒ…å†µ
    UnKnown = 0,
    /// ç¾¤èŠç›®æ ‡ï¼šæ¶ˆæ¯å‘é€åˆ°ç¾¤ç»„
    Group = 1,
    /// å•èŠç›®æ ‡ï¼šæ¶ˆæ¯å‘é€åˆ°ä¸ªäººç”¨æˆ·
    Single = 2,
}
impl ChatTargetType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::UnKnown => "UN_KNOWN",
            Self::Group => "GROUP",
            Self::Single => "SINGLE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UN_KNOWN" => Some(Self::UnKnown),
            "GROUP" => Some(Self::Group),
            "SINGLE" => Some(Self::Single),
            _ => None,
        }
    }
}
/// ======================================
/// ğŸ“¦ å­—èŠ‚æ¶ˆæ¯ç±»å‹æšä¸¾
/// ======================================
/// ç”¨äºæ ‡è¯†é€šè¿‡ WebSocket ä¼ è¾“çš„äºŒè¿›åˆ¶æ¶ˆæ¯ç±»å‹
/// è¿™äº›ç±»å‹ç”¨äºæ¶ˆæ¯è·¯ç”±å’Œåˆ†å‘ï¼Œç¡®ä¿æ¶ˆæ¯è¢«æ­£ç¡®å¤„ç†
/// æ¶ˆæ¯ç±»å‹æšä¸¾ï¼šç”¨äºæ ‡è¯†é€šä¿¡åè®®ä¸­çš„æ¶ˆæ¯åˆ†ç±»
#[derive(serde::Serialize, serde::Deserialize, utoipa::ToSchema)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ByteMessageType {
    /// æœªçŸ¥æ¶ˆæ¯ç±»å‹ï¼ˆé»˜è®¤ï¼‰ï¼šç”¨äºè§£æé”™è¯¯æˆ–æœªå®šä¹‰å¤„ç†
    UnknownByteMessageType = 0,
    /// ç³»ç»ŸåŸºç¡€é€šä¿¡ï¼ˆ1~9ï¼‰
    ///
    /// å¿ƒè·³æ¶ˆæ¯ï¼šä¿æŒè¿æ¥æ´»è·ƒ
    HeartbeatMsgType = 1,
    /// è®¤è¯è¯·æ±‚ï¼šå®¢æˆ·ç«¯å‘èµ·èº«ä»½éªŒè¯
    LoginReqMsgType = 2,
    /// è®¤è¯å“åº”ï¼šæœåŠ¡ç«¯è¿”å›è®¤è¯ç»“æœ
    LoginRespMsgType = 3,
    /// ç™»å‡ºè¯·æ±‚ï¼šå®¢æˆ·ç«¯ä¸»åŠ¨æ–­å¼€è¿æ¥
    LogoutReqMsgType = 4,
    /// ç™»å‡ºå“åº”ï¼šæœåŠ¡ç«¯ç¡®è®¤ç™»å‡ºçŠ¶æ€
    LogoutRespMsgType = 5,
    /// éªŒè¯ç è¯·æ±‚ï¼šçŸ­ä¿¡/é‚®ä»¶éªŒè¯ç å‘é€è¯·æ±‚
    SendVerificationCodeReqMsgType = 6,
    /// éªŒè¯ç å“åº”ï¼šéªŒè¯ç å‘é€å¤„ç†ç»“æœ
    SendVerificationCodeRepMsgType = 7,
    /// ç³»ç»Ÿé€šçŸ¥ï¼šå¹³å°æˆ–æœåŠ¡çº§æ¶ˆæ¯
    SystemNotificationMsgType = 8,
    /// ç”¨æˆ·åˆ·æ–°ï¼šèµ„æ–™/çŠ¶æ€/é…ç½®å˜æ›´é€šçŸ¥
    UserFlushMsgType = 9,
    /// ç”¨æˆ·åœ¨çº¿çŠ¶æ€ï¼ˆ10~19ï¼‰
    ///
    /// ç”¨æˆ·ä¸Šçº¿é€šçŸ¥
    OnlineStatusMsgType = 10,
    /// ç”¨æˆ·ä¸‹çº¿é€šçŸ¥
    OfflineStatusMsgType = 11,
    /// èŠå¤©æ¶ˆæ¯ï¼ˆ20~29ï¼‰
    ///
    /// å•èŠæ¶ˆæ¯
    UserMsgType = 20,
    /// ç¾¤èŠæ¶ˆæ¯
    GroupMsgType = 21,
    /// å¥½å‹ / ç¾¤ç»„äº‹ä»¶ï¼ˆ30~39ï¼‰
    ///
    /// å¥½å‹äº‹ä»¶ï¼šç”³è¯·ã€åŒæ„ã€åˆ é™¤ç­‰
    FriendEventMsgType = 30,
    /// ç¾¤åˆ›å»ºé€šçŸ¥
    GroupCreateMsgType = 31,
    /// ç¾¤è§£æ•£é€šçŸ¥
    GroupDismissMsgType = 32,
}
impl ByteMessageType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::UnknownByteMessageType => "UNKNOWN_BYTE_MESSAGE_TYPE",
            Self::HeartbeatMsgType => "HeartbeatMsgType",
            Self::LoginReqMsgType => "LoginReqMsgType",
            Self::LoginRespMsgType => "LoginRespMsgType",
            Self::LogoutReqMsgType => "LogoutReqMsgType",
            Self::LogoutRespMsgType => "LogoutRespMsgType",
            Self::SendVerificationCodeReqMsgType => "SendVerificationCodeReqMsgType",
            Self::SendVerificationCodeRepMsgType => "SendVerificationCodeRepMsgType",
            Self::SystemNotificationMsgType => "SystemNotificationMsgType",
            Self::UserFlushMsgType => "UserFlushMsgType",
            Self::OnlineStatusMsgType => "OnlineStatusMsgType",
            Self::OfflineStatusMsgType => "OfflineStatusMsgType",
            Self::UserMsgType => "UserMsgType",
            Self::GroupMsgType => "GroupMsgType",
            Self::FriendEventMsgType => "FriendEventMsgType",
            Self::GroupCreateMsgType => "GroupCreateMsgType",
            Self::GroupDismissMsgType => "GroupDismissMsgType",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNKNOWN_BYTE_MESSAGE_TYPE" => Some(Self::UnknownByteMessageType),
            "HeartbeatMsgType" => Some(Self::HeartbeatMsgType),
            "LoginReqMsgType" => Some(Self::LoginReqMsgType),
            "LoginRespMsgType" => Some(Self::LoginRespMsgType),
            "LogoutReqMsgType" => Some(Self::LogoutReqMsgType),
            "LogoutRespMsgType" => Some(Self::LogoutRespMsgType),
            "SendVerificationCodeReqMsgType" => {
                Some(Self::SendVerificationCodeReqMsgType)
            }
            "SendVerificationCodeRepMsgType" => {
                Some(Self::SendVerificationCodeRepMsgType)
            }
            "SystemNotificationMsgType" => Some(Self::SystemNotificationMsgType),
            "UserFlushMsgType" => Some(Self::UserFlushMsgType),
            "OnlineStatusMsgType" => Some(Self::OnlineStatusMsgType),
            "OfflineStatusMsgType" => Some(Self::OfflineStatusMsgType),
            "UserMsgType" => Some(Self::UserMsgType),
            "GroupMsgType" => Some(Self::GroupMsgType),
            "FriendEventMsgType" => Some(Self::FriendEventMsgType),
            "GroupCreateMsgType" => Some(Self::GroupCreateMsgType),
            "GroupDismissMsgType" => Some(Self::GroupDismissMsgType),
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize, utoipa::ToSchema)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Gender {
    /// æœªçŸ¥
    Unknown = 0,
    /// ç”·æ€§
    Male = 1,
    /// å¥³æ€§
    Female = 2,
}
impl Gender {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "Unknown",
            Self::Male => "Male",
            Self::Female => "Female",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "Unknown" => Some(Self::Unknown),
            "Male" => Some(Self::Male),
            "Female" => Some(Self::Female),
            _ => None,
        }
    }
}
/// ==========================
/// ğŸš¦ åŠ å¥½å‹ç­–ç•¥ï¼ˆæšä¸¾å®šä¹‰ï¼‰
/// ==========================
#[derive(serde::Serialize, serde::Deserialize, utoipa::ToSchema)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum FriendPolicy {
    /// å…è®¸ä»»ä½•äººæ·»åŠ å¥½å‹
    AllowAny = 0,
    /// éœ€è¦éªŒè¯
    NeedConfirm = 1,
    /// æ‹’ç»ä»»ä½•äººæ·»åŠ 
    DenyAny = 2,
}
impl FriendPolicy {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::AllowAny => "ALLOW_ANY",
            Self::NeedConfirm => "NEED_CONFIRM",
            Self::DenyAny => "DENY_ANY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ALLOW_ANY" => Some(Self::AllowAny),
            "NEED_CONFIRM" => Some(Self::NeedConfirm),
            "DENY_ANY" => Some(Self::DenyAny),
            _ => None,
        }
    }
}
